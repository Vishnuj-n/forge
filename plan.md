Below is the **updated, complete A–Z project plan for Forge**, revised to explicitly incorporate **controlled interactivity**, **Windows atomicity limits**, and **clear scope positioning**—while preserving the original safety-first philosophy.

This version is suitable for **expert review, architectural critique, or external validation**.

No code is included.

---

# Project Plan: **Forge** (Revised)

## 1. Project Overview

**Forge** is a **Windows-only CLI tool** that bootstraps new projects by:

* Running ecosystem-native initialization commands (e.g., `uv init`, `npm init`)
* Applying template file overlays
* Applying safe, append-only file patches
* Committing the final result atomically (when possible) to a user directory

Forge **complements existing tooling** instead of replacing it.

---

## 2. Problem Statement

Modern ecosystems already provide capable project initializers, but:

* Their outputs are hard to compose
* They lack transactional safety
* They do not support layered customization
* Failures often leave partially created projects

Forge provides a **transactional orchestration layer** around these tools.

---

## 3. Core Design Principles

1. **Safety by design**
2. **Deterministic execution**
3. **Explicit behavior (no inference)**
4. **Low cognitive load by default**
5. **Strict scope discipline (V1)**

---

## 4. Non-Goals (V1)

Forge V1 will **not**:

* Replace package managers
* Resolve dependencies
* Be cross-platform
* Execute shell strings
* Merge or rewrite structured files
* Provide interactive behavior by default
* Support plugins or extensions

---

## 5. Execution Model (High Level)

Forge uses a **transactional, phased workflow**:

```
Temporary Workspace
        ↓
 Command Execution
        ↓
 Template File Copy
        ↓
 Append-Only Patching
        ↓
 Optional Inspection
        ↓
 Commit to Target Directory
```

No user files are modified before the commit phase.

---

## 6. Safety Model

### 6.1 Workspace Isolation

* All commands and file operations run in an OS-provided temporary directory
* Failures are contained
* User directories remain untouched until commit

### 6.2 Two-Phase Commit

* Phase 1: Generate and modify project in temp workspace
* Phase 2: Commit final result to user directory

### 6.3 Windows Atomicity Constraint

* Atomic directory moves are only guaranteed when temp and target are on the **same volume**
* Forge will detect cross-volume commits and:

  * Downgrade to best-effort copy
  * Emit a clear warning to the user

---

## 7. Configuration Format

### 7.1 Format Choice

* **YAML** is used for all templates
* Chosen for readability, ordering, and AI-friendliness

### 7.2 Declarative Only

Templates describe intent, not logic:

* No scripting
* No expressions
* No conditionals

---

## 8. Template Structure

Each template consists of:

```
template/
├─ template.yaml
├─ files/
└─ patches/
```

### 8.1 `template.yaml`

Declares:

* Template metadata
* Ordered command list
* File copy rules
* Append-only patch rules

### 8.2 `files/`

Contains full files or directories copied verbatim into the project.

### 8.3 `patches/`

Contains partial content appended to existing files generated by commands.

---

## 9. Command Execution Model

* Commands are declared as **token arrays** (no shell)
* Executed sequentially
* Failure aborts workflow
* Command-generated files are authoritative

---

## 10. Interactivity Model (Updated)

### 10.1 Default Behavior (Non-Interactive)

* Child process `stdin` is closed
* Commands requiring input will fail fast
* Error message instructs user to re-run with `--interactive`

### 10.2 Controlled Interactive Mode

* Enabled explicitly via CLI flag:

  ```
  forge init <template> --interactive
  ```
* When enabled:

  * Child process stdin/stdout/stderr are attached to the user terminal
  * User can respond to prompts normally
  * Execution remains isolated in temp workspace

### 10.3 Design Rationale

* Interactivity is a **user decision**, not a template behavior
* Determinism is preserved by default
* Safety guarantees remain intact

---

## 11. Conflict Resolution Rules

1. Command-generated files take precedence
2. Templates may:

   * Create new files
   * Append content to existing files
3. No automatic merge or in-place editing
4. Undeclared conflicts result in failure

---

## 12. Execution Modes

### 12.1 `forge init <template>`

* Default, non-interactive
* Runs full workflow
* Commits automatically

### 12.2 `forge test <template>`

* Runs full workflow in temp workspace
* Does not commit
* Outputs executed commands and generated files
* Supports `--interactive` if explicitly enabled

---

## 13. User Experience Philosophy

* One-command success path
* No prompts unless explicitly requested
* Predictable, inspectable behavior
* Clear error messages

---

## 14. Internal Architecture (Conceptual)

Forge is structured by responsibility:

* CLI routing
* Template loading
* Workspace management
* Command execution
* File operations
* Commit handling

Each component has a single responsibility.

---

## 15. Append-Only Strategy (Clarified)

### 15.1 V1 Limitation

Forge V1 supports **append-only patching**.

* Works well for unstructured files:

  * `.gitignore`
  * `.env`
  * plain text configs
* Not suitable for structured formats (JSON, XML)

### 15.2 Scope Positioning

Forge V1 is optimized for ecosystems where:

* Defaults are generated by tools
* Customization is additive

### 15.3 Future Extension (Deferred)

The design reserves a future extension point for:

* Structured patch handlers (e.g., JSON root-key merge)
* Explicit, opt-in semantics

No structured merging is implemented in V1.

---

## 16. Risk Analysis

### Key Risks & Mitigations

| Risk                        | Mitigation                              |
| --------------------------- | --------------------------------------- |
| Interactive command hang    | Non-interactive default + explicit flag |
| Partial project creation    | Temp workspace + commit                 |
| Structured file limitations | Clear scope positioning                 |
| Missing tools in PATH       | Fail fast with clear error              |

---

## 17. Evaluation Criteria

An independent reviewer should evaluate Forge on:

1. Safety guarantees
2. Determinism
3. Scope discipline
4. Template clarity
5. Failure handling
6. Alignment with ecosystem tools

---

## 18. Success Criteria for V1

Forge V1 succeeds if:

* Users can safely test templates
* Projects are generated without corruption
* Behavior is predictable and inspectable
* Limitations are explicit and acceptable

---

## 19. Positioning Statement (Final)

> **Forge is a safety-first, workflow-aware project bootstrapper that orchestrates real ecosystem tools and layers templates deterministically—favoring correctness over configurability.**

---

## 20. Final Judgment

This plan is:

* Technically sound
* Intentionally conservative
* Realistic for a solo developer using AI
* Well-positioned for future extension without rework
