package scaffold

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// Compile regex pattern once at package level
var templateNamePattern = regexp.MustCompile(`^[a-zA-Z0-9_-]+$`)

// Generator creates new template scaffolds
type Generator struct {
	BaseDir string
}

// New creates a new scaffold generator
func New(baseDir string) *Generator {
	return &Generator{
		BaseDir: baseDir,
	}
}

// ValidateName checks if template name is valid
func ValidateName(name string) error {
	if name == "" {
		return fmt.Errorf("template name cannot be empty")
	}

	if len(name) > 50 {
		return fmt.Errorf("template name must be 50 characters or less")
	}

	// Allow alphanumeric, hyphens, underscores
	if !templateNamePattern.MatchString(name) {
		return fmt.Errorf("template name can only contain letters, numbers, hyphens, and underscores")
	}

	return nil
}

// Generate creates a new template scaffold
func (g *Generator) Generate(templateName string) (string, error) {
	// Validate name
	if err := ValidateName(templateName); err != nil {
		return "", err
	}

	// Create template directory
	templateDir := filepath.Join(g.BaseDir, templateName)

	// Check if already exists
	if _, err := os.Stat(templateDir); err == nil {
		return "", fmt.Errorf("template directory already exists: %s", templateDir)
	}

	// Create directory structure
	if err := os.MkdirAll(filepath.Join(templateDir, "files"), 0755); err != nil {
		return "", fmt.Errorf("failed to create files directory: %w", err)
	}

	if err := os.MkdirAll(filepath.Join(templateDir, "patches"), 0755); err != nil {
		return "", fmt.Errorf("failed to create patches directory: %w", err)
	}

	// Generate template.yaml
	yamlContent := generateTemplateYAML(templateName)
	yamlPath := filepath.Join(templateDir, "template.yaml")
	if err := os.WriteFile(yamlPath, []byte(yamlContent), 0644); err != nil {
		return "", fmt.Errorf("failed to write template.yaml: %w", err)
	}

	// Generate README.md
	readmeContent := generateReadme(templateName)
	readmePath := filepath.Join(templateDir, "README.md")
	if err := os.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
		return "", fmt.Errorf("failed to write README.md: %w", err)
	}

	// Create placeholder files
	filesDir := filepath.Join(templateDir, "files")
	placeholderPath := filepath.Join(filesDir, ".placeholder")
	if err := os.WriteFile(placeholderPath, []byte("# Add your template files here\n"), 0644); err != nil {
		return "", fmt.Errorf("failed to create placeholder: %w", err)
	}

	patchesDir := filepath.Join(templateDir, "patches")
	patchesPlaceholderPath := filepath.Join(patchesDir, ".placeholder")
	if err := os.WriteFile(patchesPlaceholderPath, []byte("# Add your append patches here\n"), 0644); err != nil {
		return "", fmt.Errorf("failed to create patches placeholder: %w", err)
	}

	return templateDir, nil
}

func generateTemplateYAML(name string) string {
	return fmt.Sprintf(`# Template: %s
# Generated by: forge new
# 
# This template creates new %s projects.
# Customize the metadata, commands, and files sections below.

name: %s
description: "A brief description of your template"
version: "1.0.0"

# Commands to execute in order during forge init
# Each command runs in the temporary workspace
commands:
  - cmd: ["git", "init"]
  # - cmd: ["git", "config", "user.name", "Your Name"]
  # - cmd: ["git", "config", "user.email", "your@email.com"]
  
  # Example: Interactive command (prompts user)
  # - cmd: ["npm", "init"]
  #   interactive: true
  #   test_cmd: ["npm", "init", "-y"]  # Used by forge test (no prompts)

# File operations
files:
  # Copy files or directories from template to project
  # Paths are relative to the template directory
  copy:
    # - files/README.md
    # - files/config.json
    # - files/.env.example
  
  # Append content to existing files (target must exist)
  # The target file must be created by commands or copy operations
  append:
    # - target: ".gitignore"
    #   source: "patches/gitignore.append"
    # - target: "package.json"
    #   source: "patches/package.json.append"
`, name, name, name)
}

func generateReadme(name string) string {
	return fmt.Sprintf(`# Template: %s

## Overview

This is a Forge template for bootstrapping %s projects.

## Quick Start

1. **Edit template.yaml** — Add metadata, commands, and file operations
2. **Test the template** — Run: forge test templates/%s
3. **Use the template** — Run: forge init templates/%s ./my-project

## Template Structure

- **template.yaml** — Configuration file with metadata and operations
- **files/** — Directory with files to copy into new projects
- **patches/** — Append-only content files for existing files

## Editing template.yaml

### Metadata (Optional)

Add template information at the top:

    name: %s
    description: "A brief description of what this template creates"
    version: "1.0.0"

### Commands

Define commands to run (in order) when initializing a project:

    commands:
      - cmd: ["git", "init"]
      - cmd: ["npm", "install"]
        interactive: true
        test_cmd: ["npm", "install", "--no-save"]  # For forge test (skip prompts)

**Command Fields:**
- **cmd**: Command tokens (e.g., ["npm", "init"])
- **interactive**: Set to true if command prompts the user
- **test_cmd**: Override command during forge test (avoids prompts)

### File Operations

#### Copy Files

1. Add files to the **files/** directory
2. Reference in template.yaml:

    files:
      copy:
        - files/README.md
        - files/config.json

#### Append Content

1. Create patch files in **patches/** directory
2. Reference in template.yaml:

    files:
      append:
        - target: ".gitignore"
          source: "patches/gitignore.append"

## Testing & Using

### Test the Template

Run without committing changes:

    forge test templates/%s

Use this to:
- Verify commands work correctly
- Skip interactive commands (uses test_cmd or skips with warning)
- Debug template logic

### Use the Template

Create a new project:

    forge init templates/%s ./my-project

Or pull and use from remote:

    forge pull %s
    forge init %s ./my-project

## Best Practices

- **Commands**: Use token-array format (no shell strings)
- **Deterministic**: Keep commands simple and predictable
- **Testing**: Always run forge test before publishing
- **Interactive**: Mark prompting commands with interactive: true
- **test_cmd**: Provide non-interactive override for testing

## Tips

- Target files for append operations must exist (created by commands or copy)
- Use relative paths from template root (e.g., files/name.txt)
- Commands run in a temporary workspace before committing
- Keep template.yaml well-commented for clarity

## Publishing

To share this template via GitHub:
1. Push to your GitHub repository
2. Users can pull it: forge pull your-github-repo
3. Or manually: forge pull --all (if listed in forge-templates)

## Documentation Links

- TEMPLATE-GUIDE.md — Complete template creation guide
- ARCHITECTURE.md — System design and internals
`, name, name, name, name, name, name, name, name)
}

// GetNextSteps returns helpful instructions after creating a template
func GetNextSteps(templateDir, templateName string) string {
	steps := []string{
		"✓ Template created successfully!",
		"",
		fmt.Sprintf("Location: %s", templateDir),
		"",
		"Next steps:",
		"1. Edit template.yaml with your commands and file operations",
		"2. Add files to the files/ directory",
		"3. Add append content to patches/ directory",
		fmt.Sprintf("4. Test the template: forge test templates/%s", templateName),
		fmt.Sprintf("5. Use the template: forge init templates/%s <project-dir>", templateName),
		"",
		"For detailed documentation, see: TEMPLATE-GUIDE.md",
	}

	return strings.Join(steps, "\n")
}
