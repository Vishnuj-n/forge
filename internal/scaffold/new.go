package scaffold

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// Compile regex pattern once at package level
var templateNamePattern = regexp.MustCompile(`^[a-zA-Z0-9_-]+$`)

// Generator creates new template scaffolds
type Generator struct {
	BaseDir string
}

// New creates a new scaffold generator
func New(baseDir string) *Generator {
	return &Generator{
		BaseDir: baseDir,
	}
}

// ValidateName checks if template name is valid
func ValidateName(name string) error {
	if name == "" {
		return fmt.Errorf("template name cannot be empty")
	}

	if len(name) > 50 {
		return fmt.Errorf("template name must be 50 characters or less")
	}

	// Allow alphanumeric, hyphens, underscores
	if !templateNamePattern.MatchString(name) {
		return fmt.Errorf("template name can only contain letters, numbers, hyphens, and underscores")
	}

	return nil
}

// Generate creates a new template scaffold
func (g *Generator) Generate(templateName string) (string, error) {
	// Validate name
	if err := ValidateName(templateName); err != nil {
		return "", err
	}

	// Create template directory
	templateDir := filepath.Join(g.BaseDir, templateName)

	// Check if already exists
	if _, err := os.Stat(templateDir); err == nil {
		return "", fmt.Errorf("template directory already exists: %s", templateDir)
	}

	// Create directory structure
	if err := os.MkdirAll(filepath.Join(templateDir, "files"), 0755); err != nil {
		return "", fmt.Errorf("failed to create files directory: %w", err)
	}

	if err := os.MkdirAll(filepath.Join(templateDir, "patches"), 0755); err != nil {
		return "", fmt.Errorf("failed to create patches directory: %w", err)
	}

	// Generate template.yaml
	yamlContent := generateTemplateYAML(templateName)
	yamlPath := filepath.Join(templateDir, "template.yaml")
	if err := os.WriteFile(yamlPath, []byte(yamlContent), 0644); err != nil {
		return "", fmt.Errorf("failed to write template.yaml: %w", err)
	}

	// Generate README.md
	readmeContent := generateReadme(templateName)
	readmePath := filepath.Join(templateDir, "README.md")
	if err := os.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
		return "", fmt.Errorf("failed to write README.md: %w", err)
	}

	// Create placeholder files
	filesDir := filepath.Join(templateDir, "files")
	placeholderPath := filepath.Join(filesDir, ".placeholder")
	if err := os.WriteFile(placeholderPath, []byte("# Add your template files here\n"), 0644); err != nil {
		return "", fmt.Errorf("failed to create placeholder: %w", err)
	}

	patchesDir := filepath.Join(templateDir, "patches")
	patchesPlaceholderPath := filepath.Join(patchesDir, ".placeholder")
	if err := os.WriteFile(patchesPlaceholderPath, []byte("# Add your append patches here\n"), 0644); err != nil {
		return "", fmt.Errorf("failed to create patches placeholder: %w", err)
	}

	return templateDir, nil
}

func generateTemplateYAML(name string) string {
	return fmt.Sprintf(`# Template: %s
# Generated by: forge new
# 
# This is a template for creating new projects.
# Edit the commands and files sections below to customize.

name: %s

# Commands to execute in order
# Each command is executed in the temporary workspace
commands:
  - cmd: ["git", "init"]
  # - cmd: ["git", "config", "user.name", "Your Name"]
  # - cmd: ["git", "config", "user.email", "your@email.com"]

# File operations
files:
  # Copy files or directories from this template to the project
  # Paths are relative to the template directory
  copy:
    - files/README.md
    # - files/config.json
    # - files/.env.example
  
  # Append content to existing files
  # The target file must exist (created by commands or copy operations)
  append:
    - target: ".gitignore"
      source: "patches/gitignore.append"
    # - target: "package.json"
    #   source: "patches/package.json.append"
`, name, name)
}

func generateReadme(name string) string {
	return fmt.Sprintf(`# Template: %s

## Overview

This is a Forge template for bootstrapping %s projects.

## What This Template Does

1. Initializes a git repository
2. Copies template files
3. Applies custom patches

## Getting Started

### Edit the template

1. template.yaml — Define commands and file operations
2. files/ — Add files/directories to copy into projects
3. patches/ — Add content to append to existing files

### Test the template

Run: forge test templates/%s

### Use the template

Run: forge init templates/%s ./my-project

## Prerequisites

- Git (for git init commands)
- Any other tools used in the commands section

## Customization

### Add files to copy
1. Add files to the files/ directory
2. In template.yaml, add to files.copy:
   copy:
     - files/README.md
     - files/config.json

### Add append patches
1. Create patch files in patches/
2. In template.yaml, add to files.append:
   append:
     - target: ".gitignore"
       source: "patches/gitignore.append"

### Add commands
In template.yaml, add to the commands section:
commands:
  - cmd: ["git", "init"]
  - cmd: ["echo", "Hello from template!"]

## Tips

- Commands are executed in token-array format (no shell strings)
- Target files for append operations must be created by commands or copy operations
- Use forge test to debug templates without committing
- Keep commands simple and deterministic

## For More Information

See the main Forge documentation:
- README.md — Project overview
- TEMPLATE-GUIDE.md — Complete template guide
`, name, name, name, name)
}

// GetNextSteps returns helpful instructions after creating a template
func GetNextSteps(templateDir, templateName string) string {
	steps := []string{
		"✓ Template created successfully!",
		"",
		fmt.Sprintf("Location: %s", templateDir),
		"",
		"Next steps:",
		"1. Edit template.yaml with your commands and file operations",
		"2. Add files to the files/ directory",
		"3. Add append content to patches/ directory",
		fmt.Sprintf("4. Test the template: forge test templates/%s", templateName),
		fmt.Sprintf("5. Use the template: forge init templates/%s <project-dir>", templateName),
		"",
		"For detailed documentation, see: TEMPLATE-GUIDE.md",
	}

	return strings.Join(steps, "\n")
}
